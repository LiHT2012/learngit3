{
  F:\Temp>java -version
  java version "1.8.0_92"
  Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
  Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)

  显式虚拟机类型 当前版本号等等
这里注意JVM默认开启了mixmode混合模式，这意味着JVM在运行时可以动态的把字节码编译成本地代码
}

jvm年轻代，老年代，永久代
{
  在堆中，新生代主要存放的是哪些很快就会被GC回收掉的或者不是特别大的对象（这个大就要看你是否设置了-XX：PretenureSizeThreshold 参数了）。
  新生代采用的复制算法，即将新生代分为3个区：较大的Eden和两个较小的Survivor（默认的Eden：Survivor = 8:1）。发生在新生代的GC为Minor GC 。
  在Minor GC时会将新生代中还存活着的对象复制进一个Survivor中，然后对Eden和另一个Survivor进行清理。所以，平常可用的新生代大小为Eden的大小+一个Survivor的大小。

  老年代则是存放那些在程序中经历了好几次回收仍然还活着或者特别大的对象（这个大就要看你是否设置了-XX：PretenureSizeThreshold 参数了）。
  老年代采用的是标记-清除或者标记-整理算法，这两个算法主要看虚拟机采用的哪个收集器，两种算法的区别是：标记-清除可能会产生大量连续的内存碎片。
  在老年代中的GC则为Major GC。Major GC和Full GC会造成stop-the-world。


  那么什么情况下，新生代的对象会进入老年代呢？

  首先就是分配担保机制：当Minor GC时，新生代存活的对象大于Survivor的大小时，这时一个Survivor装不下它们，那么它们就会进入老年代。

  还有其他的情况：如果设置了-XX：PretenureSizeThreshold3M 那么大于3M的对象就会直接就进入老年代。

  还有，在新生代的每一次Minor GC 都会给在新生代中的对象+1岁，默认到15岁时就会从新生代进入老年代，可以通过-XX：MaxTenuringThreshold来设置这个临界点。

  相比较而言，在老年代中的对象比新生代中的对象不易回收许多。


  JVM的方法区，也被称为永久代。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。这个区中的东西比老年代和新生代更不容易回收。
}

https://blog.csdn.net/zhb123gggggg/article/details/40901003
{
  JVM运行时数据区由程序计数器、堆、虚拟机栈、本地方法栈、方法区部分组成.
  JVM内存结构由程序计数器、堆、栈、本地方法栈、方法区等部分组成.

  1）程序计数器
   几乎不占有内存。用于取下一条执行的指令。

   2）堆
   所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，

    新生代:新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例
    旧生代:用于存放新生代中经过多次垃圾回收仍然存活的对象。

    3）栈
     每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。

     4）本地方法栈
     用于支持native方法的执行，存储了每个native方法调用的状态

     5）方法区
     存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用永久代（PermanetGeneration）来存放方法区，（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，
     没有永久代的概念，有关信息可以看周志明的书）可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。

JVM垃圾回收机制
   JVM分别对新生代和旧生代采用不同的垃圾回收机制

   新生代的GC：
   新生代通常存活时间较短，因此基于复制算法来进行回收，所谓复制算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和其中一个Survivor，
   复制到另一个之间Survivor空间中，然后清理掉原来就是在Eden和其中一个Survivor中的对象。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，
   当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从eden到 survivor，最后到老年代。

   用javavisualVM来查看，能明显观察到新生代满了后，会把对象转移到旧生代，然后清空继续装载，当旧生代也满了后，就会报outofmemory的异常

 在执行机制上JVM提供了串行GC（SerialGC）、并行回收GC（ParallelScavenge）和并行GC（ParNew）

   1）串行GC
   在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定

   2）并行回收GC
   在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数

   3）并行GC
   与旧生代的并发GC配合使用

   旧生代的GC：旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，
   回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。在执行机制上JVM提供了串行 GC（SerialMSC）、并行GC（parallelMSC）和并发GC（CMS），
   具体算法细节还有待进一步深入研究。

   以上各种GC机制是需要组合使用的

 堆大小 = 新生代 + 老年代。1：2.其中，堆的大小可以通过参数 –Xms、-Xmx 来指定
 划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收

 JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块Survivor
 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。


 GC 分为两种：Minor GC、FullGC ( 或称为 Major GC )。

     Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。
     新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。
     当一个对象被判定为 "死亡" 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。

   {
     当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳
     ( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域
     ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，
     当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定)，这些对象就会成为老年代。但这也不是一定的，
     对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。
   }

   Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。
   堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 "死掉" 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，
   并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象
 分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。

 -Xms60m -Xmx60m -Xmn20m -XX:NewRatio=2 ( 若 Xms = Xmx, 并且设定了 Xmn,那么该项配置就不需要配置了 ) -XX:SurvivorRatio=8 -XX:PermSize=30m
 -XX:MaxPermSize=30m -XX:+PrintGCDetails
 PermSize = 30m，PermGen即永久代 ( 方法区 )，它还有一个名字，叫非堆，主要用来存储由 jvm 加载的类文件信息、常量、静态变量等。

 几个常用和容易掌握的配置选项
 {
  -Xms 初始堆大小。如：-Xms256m

  -Xmx 最大堆大小。如：-Xmx512m

  -Xmn 新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%

  -Xss JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。

  -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3

  -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10

  -XX:PermSize 永久代(方法区)的初始大小

  -XX:MaxPermSize 永久代(方法区)的最大值

  -XX:+PrintGCDetails 打印 GC 信息

  -XX:+HeapDumpOnOutOfMemoryError 让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用
 }
 {
   1.当eden满了，触发young GC；
  2.young GC做2件事：一，去掉一部分没用的object；二，把老的还被引用的object发到survior里面，等下几次GC以后，survivor再放到old里面。
  3.当old满了，触发full GC。full GC很消耗内存，把old，young里面大部分垃圾回收掉。这个时候用户线程都会被block。
 }

 {
   对于新生成的对象，都放在Eden中；当Eden充满时（小孩太多 了），GC将开始工作，首先停止应用程序的运行，开始收集垃圾，把所有可找到的对象都复制到A空间中，一旦当A空间充满，
   GC就把在A空间中可找到的对象 都复制到B空间中(会覆盖原有的存储对象)，当B空间满的时间，GC就把在B空间中可找到的对象都复制到A空间中，AB在这个过程中互换角色，
   那位客官说 了：拷来拷去，烦不烦啊？什么时候是头？您别急，在活动对象经过一定次数的GC操作后，这些活动对象就会被放到旧域中。对于这些活动对象，新域的幼儿园生 活结束了。
   新域为什么要这么折腾？起初在这块我也很迷糊，又查了些资料，原来是这样：应用程序生成的绝大部分对象都是短命的，copying算法最理想的 状态是，所有移出Eden的对象都会被收集，
   因为这些都是短命鬼，经过一定次数的GC后应该被收集，那么移入到旧域的对象都是长命的，这样可以防止AB空 间的来回复制影响应用程序。实际上这种理想状态是很难达到的，应用程序中不可避免地存在长命的对象，
   copying算法的发明者要这些对象都尽量放在新域 中，以保证小范围的复制，压缩旧域的开销可比新域中的复制大得多(旧域在下面说)。对于旧域，采用的是tracing算法的一种，称为标记-清除-压缩收 集器，
   注意，这有一个压缩，这是个开销挺大的操作。垃圾回收主要是对Young Generation块和Old Generation块内存进行回收，YG用来放新产生的对象，经过几次回收还没回收掉的对象往OG中移动，
   对YG进行垃圾回收又叫做MinorGC，对 OG垃圾回收又叫MajorGC，两块内存回收互不干涉
 }

{
  如果GC执行满足了以下要求，GC并不需要优化：
  如需优化请参考：http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html
  Minor GC 执行快 (50 ms内).
  Minor GC 执行不频繁 (大概10s 执行一次).
  Full GC 执行快 (1 second内).
  Full GC 执行不频繁 (10 minutes 一次).
 }
 http://blog.longjiazuo.com/archives/5127
 面试
 {
   什么时候进行gc：
   eden满了minor gc，升到老年代的对象大于老年代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc；
   gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过 MaxTenuringThreshold控制进入老年前生存次数等
   总结：程序员不能具体控制时间，系统在不可预测的时间调用System.gc()函数的时候；当然可以通过调优，用NewRatio控制newObject和oldObject的比例，用MaxTenuringThreshold 控制进入oldObject的次数，
   使得oldObject 存储空间延迟达到full gc,从而使得计时器引发gc时间延迟OOM的时间延迟，以延长对象生存期。

   对什么东西进行gc：
   超出了作用域或引用计数为空的对象；从gc root开始搜索找不到的对象，而且经过一次标记、清理，仍然没有复活的对象。

   做什么：
   总结：删除不使用的对象，回收内存空间；运行默认的finalize,当然程序员想立刻调用就用dipose调用以释放资源如文件句柄，JVM用from survivor、to survivor对它进行标记清理，对象序列化后也可以使它复活。

 }
 {
   根搜索算法
   在主流的商用语言中，都是使用根搜索算法来判定对象是否存活的。GC Root Tracing 算法思路就是通过一系列的名为"GC  Roots"的对象作为起始点，从这些节点开始向下搜索，
   搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可用的。
 }
 {
   （4）哪那些对象可以作为GC Roots？
   虚拟机栈（栈帧中的本地变量表）中的引用的对象    方法区中的类静态属性引用的对象    方法区中的常量引用的对象    本地方法栈中JNI（Native方法）的引用对象
   （5）Java代码编译的结果是什么？         是字节码文件.class
   (6) 怎么理解Java语言的平台无关性？语言无关性？通过什么方法实现的？
   (7)Java中的static变量和static方法在JVM运行中内存的分配管理有什么不同和一般变量方法？
     静态对象                非静态对象
  拥有属性： 是类共同拥有的           是类各对象独立拥有的
  内存分配： 内存空间上是固定的        空间在各个附属类里面分配
  分配顺序： 先分配静态对象的空间      继而再对非静态对象分配空间,也就是初 始化顺序是先静态

（8）Java类的加载过程？

（9）在heap中没有类实例的时候，类信息还存在于JVM吗？ 存在于什么地方？


 }
}
