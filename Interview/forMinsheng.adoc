面向对象有清晰的认识
熟悉Java核心技术及Spring/Mybatis等主流平台框架

熟练使用DB2,Mysql等数据库进行应用开发
熟悉数据库原理及其常用性能优化技术，熟悉sql语句

了解linux/unix操作系统，熟悉weblogic/tomcat/apache/nginx等主流服务器

熟悉各类Java应用中间件，有Zookeeper/redis/activeMQ或高性能通讯框架(如MINA)

互联网金融项目

==== 面向对象

1）思想：是站在现实世界的角度去抽象和解决问题，把数据和行为都看作是对象的一部分，可以让程序员以符合现实世界的思维方式来编写和组织程序。

2）原则：

单一职责：一个类只做它该做的事（高内聚）；

开放封闭：对扩展开放，对修改关闭；

里氏替换：任何时候都可用子类型替换父类型；

依赖倒置：面向接口编程（抽象类型可被任何一个子类所替代）；

合成聚和复用：优先使用聚合或合成关系复用代码；

接口隔离：一个接口只应描述一种能力，接口应该是高内聚的（小而专一）；

迪米特法则：最少知识原则，一个对象应对其他对象尽可能少的了解。

{
  Java面向对象的特征: 抽象、封装、继承、多态.

  .. 抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面:数据抽象和过程抽象.

  .. 封装：封装就是对属性和方法的载体类,只能通过其提供的接口(方法)来访问,而把实现细节隐藏起来.也就是说,具体实现对程序员来说是透明的,封装的好处在于对类内部的改变,不会影响到其他代码.
  {
    封装的做法:

    1.私有属性(private修饰符修饰属性)。

    2.提供public的读(getXX)写(setXX)方法。

    3.在构造中调用方法.所有的非常量属性基本都需要封装.

    封装的好处：

    1.隐藏类的实现细节

    2.对所有用户提供统一的接口

    3.增强执行效果.

    4.易于维护和扩展
  }
  .. 继承:继承是一种关系,逻辑上满足子类is a 父类的关系才使用继承.
  {
    子类继承父类的属性和非私有方法.不能继承父类的构造,继承关键字extends,类单继承,接口多继承.

    在构造子类对象时,依次调用父类的构造(子类默认调用父类的无参构造.可以使用super(参数列表)来调用指定的父类的含参构造)到Object为止.再调用子类自身的.

    子类调用父类的构造时,父类的构造只能调用一个且必须写在子类构造的第一句.

    执行过程：static（father--> son）--> father（代码块 --> construct）--> son（代码块 --> construct）
  }
  .. 多态：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
  {
    多态的类型
    1.基本类型的多态(本质上是基本类型之间的自动类型转换)
    {
      基本类型自动转换为对应的封装类的操作叫做自动装箱操作,反之叫自动拆箱操作,自动装箱操作有一个自动装箱池(范围为-128~127).只要自动装箱的数在自动装箱池范围内,则直接去池中找数据.

      Integer num1 = 127;
      Integer num2 = 127;
      System.out.println(num1==num2);//true,在范围内
      Integer num3 = 128;
      Integer num4 = 128;
      System.out.println(num3==num4);//false，超过范围

      Charater在5.0没有该自动装箱池,在6.0有自动装箱池.

      byte、short、int、long有自己的自动装箱池,其他基本类型都没有该自动装箱池.

      自动装箱不会出现错误,自动解箱在下面情况下会出错
      Integer num = null;
      int i = num;//null不能自动解箱

      short a = 128;
      byte b = (byte)a;
      System.out.println("a=" + a + ",b=" + b);//a=128,b=-128
    }
    2.方法的多态(方法的重载、重写)
    {
      a)覆盖

      父类继承过来的方法对子类不合适时子类可以改变该方法的实现,这种操作叫做方法的重写/覆盖(继承是重写的前提条件)

      重写的要求:

      <1>.方法名、参数列表和返回类型必须相同(5.0以后允许返回子类类型).

      <2>.访问权限可以改但是不允许更小.(即子类的访问权限要么大于父类的要么相同,不允许小于父类的访问权限)

      <3>.抛出的异常不能更大.

      b)重载

      方法的重载要求方法名必须相同,参数必须不同(参数个数不同、类型不同、顺序不同<(int,String)和(String,int)是不一样的>).返回值类型可以相同可以不相同.
      {
        被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。
        被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。
        被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。
        覆盖和重载的不同：

        方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。
        方法覆盖要求返回类型必须一致，方法重载对此没有要求。
        方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。
        方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。
        父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次
      }
    }
    3.类或者接口的多态(父类的引用指向子类的对象)：Person p = new Student();
    {
      父类的引用指向子类的对象就发生了多态.后果：

      <1>.只能使用父类中方定义的属性和方法

      <2>.子类中定义的不能直接使用

      <3>.子类复写了父类的方法,此时调用情况根据方法是否static而不同 *[static(调用父类),非static(调用子类)]*.

      <4>.如果想使用子类中定义的方法,可以强制类型转换(判断是否可以转换,用instanceof运算符来判断对象的类型)
    }
    4.传参时的多态(基本类型的多态与类类型的多态混合使用)
  }
}
{
  Java的四种访问控制符：
  默认的（default）：不使用任何修饰符，在同一包可见。
  私有的（private）：使用private修饰，在同一类内可见。
  公共的（public）：使用public修饰，对所有类可见。
  受保护的（protected）：使用protected修饰，对同一包内和 *所有子类* 可见。//所以，父类中的字段修饰符为protected
}

==== Java核心技术

1. 基本类型的精度：
低  ------------------------------------>  高
byte,short,char—> int —> long—> float —> double
各自的位数，依次：8,16,16,32,64,32,64

2.
{
  class A {
    public A foo() {
        return this;
    }
  }

  class B extends A {
      public A foo() {
          return this;
      }
  }

  class C extends B
  {
      //这样填写什么代码不会报错
  }
  A.public void foo(){}
  B.public int foo(){return 1;}
  C.public A foo(B b){return b;}
  D.public A foo(){return A;}
  分析：
  {
    A.public void foo(){}
    返回值类型与父类不一致，所以不可能是方法的重写。又因为方法名相同，那么只能是方法重载，而方法重载有需要满足三个条件：形参个数、顺序、类型必须有一者不同，A选项都不满足，错
    B.public int foo(){return 1;}
    与A选项一样
    C.public A foo(B b){return b;}
    返回值类型与父类相同，但由于参数列表不同，所以是对父类方法的重载
    D.public A foo(){return A;}
    语法错误
  }
}

3.
值传递：Java中原始数据类型都是值传递，传递的是值的副本，形参的改变不会影响实际参数的值；
引用传递： 传递的是引用类型数据，包括String,数组，列表，map，类对象等类型，形参与实参指向的是同一内存地址，因此形参改变会影响实参的值。








如果一个类使用了其他类的实例作为自己的成员变量，那么就会产生数据抽象耦合。
