{
  你在面月薪6000-8000的Java研发职位。面试官也知道JVM这么个大体概念，但知道的也不多。JVM这个概念本身就是“底层”。JVM有一条名为 instanceof 的指令，
  而Java源码编译到Class文件时会把Java语言中的 instanceof 运算符映射到JVM的 instanceof 指令上。你可以知道Java的源码编译器之一javac是这样做的：
  instanceof 是javac能识别的一个关键字，对应到Token.INSTANCEOF的token类型。做词法分析的时候扫描到"instanceof"关键字就映射到了一个Token.INSTANCEOF token。
  jdk7u/jdk7u/langtools: 5c9759e0d341 src/share/classes/com/sun/tools/javac/parser/Token.java该编译器的抽象语法树节点有一个JCTree.JCInstanceOf类用于表示instanceof运算。
  做语法分析的时候解析到instanceof运算符就会生成这个JCTree.JCInstanceof类型的节点。
  jdk7u/jdk7u/langtools: 5c9759e0d341 src/share/classes/com/sun/tools/javac/parser/JavacParser.java term2Rest()中途还得根据Java语言规范对instanceof运算符的编译时检查的规定
  把有问题的情况找出来。到最后生成字节码的时候为JCTree.JCInstanceof节点生成instanceof字节码指令。
  jdk7u/jdk7u/langtools: 5c9759e0d341 src/share/classes/com/sun/tools/javac/jvm/Gen.java visitTypeTest()（Java语言君说：“instanceof 这问题直接交给JVM君啦”）
  （面试官：你还给我废话⋯给我进情形3！）其实能回答到这层面就已经能解决好些实际问题了，例如说需要手工通过字节码增强来实现一些功能的话，知道JVM有这么条 instanceof 指令或许正好就能让你顺利的使用 ASM 之类的库完成工作。---------------------------------------------------------------------情形3：你在面月薪10000的Java高级研发职位。面试官对JVM有一些了解，想让你说说JVM会如何实现 instanceof 指令。但他可能也没看过实际的JVM是怎么做的，只是臆想过一下而已。JVM的规定就是“底层”。这种情况就给他JVM规范对 instanceof 指令的定义就好：Chapter 6. The Java Virtual Machine Instruction Set, JVM规范Java SE 7版根据规范来臆想一下实现就能八九不离十的混过这题了
}
A公司

那现在来聊一聊我所遇到的一些面试经历，希望给各位寻求新机会的小伙伴一个参考。总共面完5家收了4个offer，应该算是比较成功的吧。

由于种种原因，文中所涉及的公司均以代号标志，且我能告诉大家的也只有面试题，其他的不便透露细节，希望大家理解。

面试题

写出java中synchronized的使用方式。
{
https://blog.csdn.net/luoweifu/article/details/46613015
A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。
B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。
C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。


1.锁其实就是一个对象，当你拿到这个对象的使用权的时候，就可以去进行被锁住的代码了，反之不行。并不存在修饰一个类的说法吧。
2.“如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。”这句话是不对的，静态同步方法的锁是类的.Class对象，非静态同步方法的锁是当前的实例对象，二者没有关系，并不互斥。
PS：我参考楼主写的分析synchronized的文章http://blog.csdn.net/sted_zxz/article/details/76862444


一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。

当有一个明确的对象作为锁时，就可以用类似下面这样的方式写程序。
public void method3(SomeObject obj)
{
   //obj 锁定的对象
   synchronized(obj)
   {
      // todo
   }
}

当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁：
class Test implements Runnable
{
   private byte[] lock = new byte[0];  // 特殊的instance变量
   public void method()
   {
      synchronized(lock) {
         // todo 同步代码块
      }
   }

   public void run() {

   }
}//说明：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。

synchronized关键字不能继承。
虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，
因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。

在定义接口方法时不能使用synchronized关键字。
构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。

synchoronized修改静态方法：
syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。

Synchronized还可作用于一个类：
class ClassName {
   public void method() {
      synchronized(ClassName.class) {
         // todo
      }
   }
}//synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁

小结如下：

搞清楚synchronized锁定的是哪个对象，就能帮助我们设计更安全的多线程程序。

还有一些技巧可以让我们对共享资源的同步访问更加安全：

1． 定义private 的instance变量+它的 get方法，而不要定义public/protected的instance变量。如果将变量定义为public，对象在外界可以
绕过同步方法的控制而直接取得它，并改动它。这也是JavaBean的标准实现方式之一。

2． 如果instance变量是一个对象，如数组或ArrayList什么的，那上述方法仍然不安全，因为当外界对象通过get方法拿到这个instance对象
的引用后，又将其指向另一个对象，那么这个private变量也就变了，岂不是很危险。 这个时候就需要将get方法也加上synchronized同步，并
且，只返回这个private对象的clone()――这样，调用端得到的就是对象副本的引用了

}



Java中设置最大堆和最小堆内存的参数是什么？

volatile的作用？
{
  用volatile修饰后的变量不允许有不同于“主”内存区域的变量拷贝。换句话说，一个变量经 volatile修饰后在所有线程中必须是同步的；任何线程中改变了它的值，所有其他线程立即获取到了相同的值。
  理所当然的，volatile修饰的变量存取时比一般变量消耗的资源要多一点，因为线程有它自己的变量拷贝更为高效。

  在使用volatile关键字时要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作都是原来操作，当变量的值由自身的上一个决定时，如n=n+1、n++ 等，volatile关键字将失效，
  只有当变量的值和自身上一个值无关时对该变量的操作才是原子级别的，如n = m + 1，这个就是原级别的。所以在使用volatile关键时一定要谨慎，如果自己没有把握，可以使用synchronized来代替volatile。

  https://www.cnblogs.com/paddix/p/5428507.html
  提醒博主：按照JLS，除了long 和 double之外的类型，读写操作本身就是原子的，不需要通过volatile修饰。
  再进一步说，如果需要确保原子操作，使用AtomicLong之类的同步类更好，这个同步类内置了很多原子操作，包括自增和自减。
  再进一步说，唯一需要用到volatile的场合是为了避免活性失败，但是又不想用锁和同步类。
vs
  AtomicLong确实可以保证原子性，也提供了很多比较方便的方法。不过如果只是单纯的对long/double读/写的话，是可以用volatile的。
  至于volatile使用的唯一场景是“避免活性失败”，在jdk 1.5之前应该是，但是jdk 1.5之后，volatile的语义是有加强的，所以应用场景也有所扩大
  {
    实例化一个对象其实可以分为三个步骤：
  　　（1）分配内存空间。
  　　（2）初始化对象。
  　　（3）将内存空间的地址赋值给对应的引用
    但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：
  　　（1）分配内存空间。
  　　（2）将内存空间的地址赋值给对应的引用。
  　　（3）初始化对象

  　　如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。

  可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。

  因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，
  这样能保证任何情况下对long和double的单次读/写操作都具有原子性。

  必须同时满足下面两个条件才能保证在并发环境的线程安全：
　　（1）对变量的写操作不依赖于当前值。
　　（2）该变量没有包含在具有其他变量的不变式中。
    https://my.oschina.net/tantexian/blog/808032
  volatile关键字的两层语义

　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　2）禁止进行指令重排序。

  volatile的可见性，即任何时刻只要有任何线程修改了volatile变量的值，其他线程总能获取到该最新值

    内存屏障有两个能力：
    1. 阻止屏障两边的指令重排序
    2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效

    对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据
    对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。
  }
  {
    https://blog.csdn.net/xilove102/article/details/52437581
    Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，
    但是它所能实现的功能也仅是 synchronized 的一部分。

    volatile的使用条件：
    volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。
    Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类
    （例如 “start <=end”）。

    出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，
    因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。

    {
      volatile的适用场景
      模式 #1：状态标志
      也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。
        volatile boolean shutdownRequested;
        ...

        public void shutdown() {
           shutdownRequested = true;
        }
        public void doWork() {
           while (!shutdownRequested) {
               // do stuff
           }
        }
        线程1执行doWork()的过程中，可能有另外的线程2调用了shutdown，所以boolean变量必须是volatile。
        而如果使用 synchronized 块编写循环要比使用 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。
        这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从false 转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下
        才能扩展（从false 到true，再转换到false）。此外，还需要某些原子状态转换机制，例如原子变量


        模式 #2：一次性安全发布（one-time safe publication）

        在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。

        这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。参见：【设计模式】5. 单例模式（以及多线程、无序写入、volatile对单例的影响）
        //注意volatile！！！！！！！！！！！！！！！！！
          private volatile static Singleton instace;

          public static Singleton getInstance(){
              //第一次null检查
              if(instance == null){
                  synchronized(Singleton.class) {    //1
                      //第二次null检查
                      if(instance == null){          //2
                          instance = new Singleton();//3
                      }
                  }
              }
              return instance;


        如果不用volatile，则因为内存模型允许所谓的“无序写入”，可能导致失败。——某个线程可能会获得一个未完全初始化的实例。

        考察上述代码中的 //3 行。此行代码创建了一个 Singleton 对象并初始化变量 instance 来引用此对象。这行代码的问题是：在Singleton 构造函数体执行之前，变量instance 可能成为非 null 的！
        什么？这一说法可能让您始料未及，但事实确实如此。

        在解释这个现象如何发生前，请先暂时接受这一事实，我们先来考察一下双重检查锁定是如何被破坏的。假设上述代码执行以下事件序列：

              线程 1 进入 getInstance() 方法。
              由于 instance 为 null，线程 1 在 //1 处进入synchronized 块。
              线程 1 前进到 //3 处，但在构造函数执行之前，使实例成为非null。
              线程 1 被线程 2 预占。
              线程 2 检查实例是否为 null。因为实例不为 null，线程 2 将instance 引用返回，返回一个构造完整但部分初始化了的Singleton 对象。
              线程 2 被线程 1 预占。
              线程 1 通过运行 Singleton 对象的构造函数并将引用返回给它，来完成对该对象的初始化。


        模式 #3：独立观察（independent observation）

        安全使用 volatile 的另一种简单模式是：定期 “发布” 观察结果供程序内部使用。【例如】假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。

        使用该模式的另一种应用程序就是收集程序的统计信息。【例】如下代码展示了身份验证机制如何记忆最近一次登录的用户的名字。将反复使用lastUser 引用来发布值，以供程序的其他部分使用。
        public class UserManager {
              public volatile String lastUser; //发布的信息

              public boolean authenticate(String user, String password) {
                  boolean valid = passwordIsValid(user, password);
                  if (valid) {
                      User u = new User();
                      activeUsers.add(u);
                      lastUser = user;
                  }
                  return valid;
              }
          }


        模式 #4：“volatile bean” 模式

        volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。

        在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通——即不包含约束！
          @ThreadSafe
          public class Person {
              private volatile String firstName;
              private volatile String lastName;
              private volatile int age;

              public String getFirstName() { return firstName; }
              public String getLastName() { return lastName; }
              public int getAge() { return age; }

              public void setFirstName(String firstName) {
                  this.firstName = firstName;
              }

              public void setLastName(String lastName) {
                  this.lastName = lastName;
              }

              public void setAge(int age) {
                  this.age = age;
              }
          }

        模式 #5：开销较低的“读－写锁”策略

        如果读操作远远超过写操作，您可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。

        如下显示的线程安全的计数器，使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。

          @ThreadSafe
          public class CheesyCounter {
              // Employs the cheap read-write lock trick
              // All mutative operations MUST be done with the 'this' lock held
              @GuardedBy("this") private volatile int value;

              //读操作，没有synchronized，提高性能
              public int getValue() {
                  return value;
              }

              //写操作，必须synchronized。因为x++不是原子操作
              public synchronized int increment() {
                  return value++;
              }

        使用锁进行所有变化的操作，使用 volatile 进行只读操作。
        其中，锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作
        
    }
  }
}

一道设计题

多个线程同时读写，读线程的数量远远于写线程，你认为应该如何解决 并发的问题？你会选择加什么样的锁？

JAVA的AQS是否了解，它是嘛的？

除了synchronized关键字之外，你是怎么来保障线程安全的？

什么时候需要加volatile关键字？它能保证线程安全吗？

B公司

1.：“请你自我介绍一下”

2.：“你有什么业余爱好？”

3.：“你认为你工作中的哪些方面是最重要的？”

4.：“谈谈你的缺点”

5.：“谈一谈你的一次失败经历”

6.：“你为什么选择我们公司？”

7.：“对这项工作，你有哪些可预见的困难？”

8.：“我们为什么要录用你？”

9.：“您在前一家公司的离职原因是什么？”

C公司

1.你知道哪些或者你们线上使用什么GC策略? 它有什么优势，适用于什么 场景？

2.JAVA类加载器包括几种？它们之间的关系是怎么样的？双亲委派机 制是什么意思？

有什么好处？

3.如何定义个类加载器？你使用过哪些或者你在什么场景下需要定义的类加载器？

4. Perm Space中保存什么数据? 会引起OutOfMemory吗？ 5.做gc时，对象在内存各

个Space中被移动的顺序是什么？

6.你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有

哪些收获？

7.1.8之后Perm Space有哪些变动? MetaSpace默认是限的么? 还是 你们会通过什

么式来指定?

8.Jstack是什么的? Jstat呢? 如果线上程序周期性地出现卡顿，你怀疑可 能是gc

导致的，你会怎么来排查这个问题？线程日志一般你会看其中的什么 部分？

9.StackOverFlow异常有没有遇到过？一般你猜测会在什么情况下被触 发？

如何指定一个线程的堆栈？一般你们写多少？

下面是小编整理的一整套系统的Java学习教程，进扣君羊：前面三位数是616中间是959后面是444即可免费领取一整套系统的Java学习教程！

======
工作两年正好是一个重要的时间节点。在这个时候我认为有几个比较重要的事情需要做：
1：建立自己的技术体系之前可能学的东西比较零散，比较杂，这个时候是该将所学有体系的组织起来。
2：基础。thinking in java 在啃几遍，jvm相关的东西再看看，框架的源码再拿出来翻翻，涉及到的设计模式是不是也重新温习一下。
数据结构，算法，网络也适当的看看。3：就是一些企业级的应用技术了。比如消息中间件，服务中间件，如何建立高可用的应用等。
这部分的内容需要去一个大一点的企业能力才能提升上来。
4：是积累人脉和行业经验。其实这个是很多技术人员都忽略的一个方面，但是又非常重要。
======

{
1 JVM: 内存分析与调优，类加载机制，字节码基本结构。2 并发：jdk自身的并发库; 第三方的库或者框架，akka,vertx,...3 jvm平台的潜力语言:Scala,groovy4 J2EE：基本概念:sevlet,jpa，...; 相关框架:spring,hibernate；容器:Jetty,tomcat5 Osgi6 Maven,gradle
http://www.offcn.com/it/2018/0123/18896_2.html

较多企业会希望Java工程师最好熟悉一点前端技术，前端与后端基数相结合，将有助于求职时提高获得offer的机会。

总的来说，企业更喜欢一专多能式职业技能人才，单一技能的前端/后端程序员已经不能满足企业的需求，而且事实上Java已经成为全栈前端和后端开发中最流行的语言，所以要学编程学习全栈开发，全栈开发包括Java开发。东时为真而来，历经多年时间研究探索推出前端HTML5+后端Java+数据库的多技能的全栈培训课程，力求为高中端企业打造掌控全局式全栈开发工程师。

https://www.jianshu.com/p/39a667b495cc
http://baijiahao.baidu.com/s?id=1588652546994154393&wfr=spider&for=pc
}

基础问题和思想：
1、抽象类和接口的区别（单纯的语法区别只能给一半分，要说出来适用场景）；
2、hashcode()和equals()的关系；
3、HashMap（Set）底层机制（用到的数据结构以及代码原理）；
4、Object的常用的一些方法；
5、讲一下反射以及用到的场景；
6、Spring 主要做了哪些工作（IOC 事务AOP 逻辑AOP等）；
7、IOC和AOP以及应用场景；
8、JVM的内存管理和GC；
9、OOM的解决方案（关联问题8）；
10、JVM ClassLoader原理；
11、怎么新开线程，线程安全怎么控制，ThreadLocal有什么用，HashMap怎么做到线程安全，怎么解决死锁的问题；
12、说几个常用的设计模式和应用场景；
13、java代理机制；
14、多服务器的session共享解决方案；
15、zookeeper的工作原理；
16、soa架构模式有什么好处；


数据库方面：
1、数据库连接池机制；
2、数据库隔离级别有哪些，mysql默认级别是哪个；
3、inner join、left join、right join、group by、having是怎么用的（给出2个表，手写查询语句）；
4、char和varchar的区别；
5、数据库方面的性能优化；
6、mysql的索引类型、区别、以及如何选取，画出btree是怎么存的，什么时候索引会失效
7、mysql表存储引擎有哪些，如何选取
8、分表的解决方案
9、hash分表怎么分

实战问题：
1、一个请求超过20秒了，你怎么排查和解决；
2、说说你觉得做的比较不错的项目，讲一下项目结构和用到的框架，再说一下为什么要选择这些框架；
3、“商品秒杀”的解决方案；
4、手写个单例模式出来；
5、分布式锁的解决方案
6、分布式事务解决方案
7、分布式环境下的定时任务管理

前端的一些问题，比如jquery的ajax的参数都是做什么用的，CSS框架和JS框架都用过哪些，怎么解决跨域的问题


1.有抽象方法且abstract标示就是抽象类,方法不具体但不要求一定要重写方法,抽象方法没有主体,接口全是抽象方法且实现之后全得重写,如listener和适配器,Action和ActionSupport
2.在set中的存储方式先判断hashcode是否相等,再判断equals是否相等,两个都相等,如果两个都相等视为相等
3.双列的HashSet,大概吧
4.toString ,equals,
5.接口增加了程序的灵活性,反射是比接口更加灵活的技术,可以抽象到任意的类,执行满足一些条件的方法,定义一个功能,可以使用class作为传参而不确定具体的类或者接口,可以是任何类,与接口比较相似,接口可以事先调用没写好的方法,而反射可以事先调用满足一些名字约束的方法
,而且反射可以使用私有的方法和字段
7.ioc:控制反转=di:注入,在struts中action的初始化由别的类完成,调用set方法而不是构造器给字段赋值,AOP:没学
8:当一个对象没有被栈中的变量指向时,也就是被系统判断无法再被使用,经过一段不确定的时间会被gc垃圾回收装置回收,通常使用varName=null;来手动释放内存,但不会马上被释放
11.继承Thread或者实现Runnable,重写run方法通过start开启多线程,多个线程操作同个数据时,那部分加上同步代码块,随便加个对象作为锁,或者给方法加上Synchornized,或者通过Lock类开锁解锁
,HashMap换HashTable,怎么解决死锁:别瞎写代码就不会死锁,就是别嵌套锁
12:单例模式:只能有一个对象,不知道有什么用,工厂模式:把创建对象的功能分出一个类:不知道有啥用
13:代理模式:代理类包含被代理类的对象的字段,代理类的构造函数传入被代理对象,在代理类写被代理类的同名方法,在此方法中调用原方法并在外部加以修改,如果要修改原方法内部,使用反射
:用途:和接口相似:接口是方法抽象,代理模式是对象抽象,对象不确定,由别人传入,或者是另一种情况:需要修改一个类的方法
6.9.10.14.15.16没听过


数据库
1.连接池:连接对象的集合,连接资源宝贵需要对连接管理 操作结束需要关闭连接 对象置空
建立一个连接要耗费资源 保持连接要耗费资源 连接池的意义就是对于常用的连接保持开启 ,超出数量的连接才创建和关闭
内置了一个list用于保存连接对象,自制的连接池就算放回了也可以继续使用的
3.只知道group by//分组查询 select * form 表 group by 列名 ,按一个的项分组,比如gender 男的一组女的一组,应该和其他条件比如count一起使用
having就是where,where在使用函数时无法使用换having
4,字符和字符串,char没用过,可能只能单字符吧
5.索引吧,建立索引,主键本身就是一个索引,其他不重复的列也可以作为索引,用索引作为条件查起来快,只知道这个
6.只记得一个索引类型是不重复
789不会


实战:
1.可能是服务器负荷过大,配置一个struts自带的拦截器execAndWite,当用户访问action时时间过长使其跳转到一个页面重复提交请求,可以让action先跳转到别的页面缩小问题的范围,或者先注释掉service的调用,同样是缩小问题范围
4:简单,所以具体代码就不写了,先私有化构造函数,class下声明自己实例的变量,在静态代码块或者直接在class下新建自己实例对象;在写个getInstance获得这个对象,懒汉式的就在方法内创建对象,如果为对象的字段为空就创建,不为空就直接返回这个对象好了
23567都不会,后面前端的东西不会


zookeeper常见面试题
zookeeper是如何保证事务的顺序一致性的
zookeeper采用了递增的事务Id来标识，所有的proposal都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行


zookeeper是如何选取主leader的？
当leader崩溃或者leader失去大多数的follower，这时zk进入恢复模式，


zk中znode类型有四种，持久化目录节点 持久化顺序编号目录节点(有顺序 能够在注册机器等许多场景用到) 临时目录节点 临时顺序编号节点
zk的通知机制
client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。


zk的配置管理
程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用water通知给各个客户端 从而更改配置。
zk的命名服务
命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。


分布式通知和协调
对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点的watcher的所有客户端。
对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。


机器中为什么会有master；
在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行master选举。

redis面试题
https://www.cnblogs.com/jiahaoJAVA/p/6244278.html
https://www.cnblogs.com/Survivalist/p/8119891.html
