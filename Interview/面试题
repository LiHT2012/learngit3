基础问题和思想：
1、抽象类和接口的区别（单纯的语法区别只能给一半分，要说出来适用场景）；
2、hashcode()和equals()的关系；
3、HashMap（Set）底层机制（用到的数据结构以及代码原理）；
4、Object的常用的一些方法；
5、讲一下反射以及用到的场景；
6、Spring 主要做了哪些工作（IOC 事务AOP 逻辑AOP等）；
7、IOC和AOP以及应用场景；
8、JVM的内存管理和GC；
9、OOM的解决方案（关联问题8）；
10、JVM ClassLoader原理；
11、怎么新开线程，线程安全怎么控制，ThreadLocal有什么用，HashMap怎么做到线程安全，怎么解决死锁的问题；
12、说几个常用的设计模式和应用场景；
13、java代理机制；
14、多服务器的session共享解决方案；
15、zookeeper的工作原理；
16、soa架构模式有什么好处；


数据库方面：
1、数据库连接池机制；
2、数据库隔离级别有哪些，mysql默认级别是哪个；
3、inner join、left join、right join、group by、having是怎么用的（给出2个表，手写查询语句）；
4、char和varchar的区别；
5、数据库方面的性能优化；
6、mysql的索引类型、区别、以及如何选取，画出btree是怎么存的，什么时候索引会失效
7、mysql表存储引擎有哪些，如何选取
8、分表的解决方案
9、hash分表怎么分

实战问题：
1、一个请求超过20秒了，你怎么排查和解决；
2、说说你觉得做的比较不错的项目，讲一下项目结构和用到的框架，再说一下为什么要选择这些框架；
3、“商品秒杀”的解决方案；
4、手写个单例模式出来；
5、分布式锁的解决方案
6、分布式事务解决方案
7、分布式环境下的定时任务管理

前端的一些问题，比如jquery的ajax的参数都是做什么用的，CSS框架和JS框架都用过哪些，怎么解决跨域的问题


1.有抽象方法且abstract标示就是抽象类,方法不具体但不要求一定要重写方法,抽象方法没有主体,接口全是抽象方法且实现之后全得重写,如listener和适配器,Action和ActionSupport
2.在set中的存储方式先判断hashcode是否相等,再判断equals是否相等,两个都相等,如果两个都相等视为相等
3.双列的HashSet,大概吧
4.toString ,equals,
5.接口增加了程序的灵活性,反射是比接口更加灵活的技术,可以抽象到任意的类,执行满足一些条件的方法,定义一个功能,可以使用class作为传参而不确定具体的类或者接口,可以是任何类,与接口比较相似,接口可以事先调用没写好的方法,而反射可以事先调用满足一些名字约束的方法
,而且反射可以使用私有的方法和字段
7.ioc:控制反转=di:注入,在struts中action的初始化由别的类完成,调用set方法而不是构造器给字段赋值,AOP:没学
8:当一个对象没有被栈中的变量指向时,也就是被系统判断无法再被使用,经过一段不确定的时间会被gc垃圾回收装置回收,通常使用varName=null;来手动释放内存,但不会马上被释放
11.继承Thread或者实现Runnable,重写run方法通过start开启多线程,多个线程操作同个数据时,那部分加上同步代码块,随便加个对象作为锁,或者给方法加上Synchornized,或者通过Lock类开锁解锁
,HashMap换HashTable,怎么解决死锁:别瞎写代码就不会死锁,就是别嵌套锁
12:单例模式:只能有一个对象,不知道有什么用,工厂模式:把创建对象的功能分出一个类:不知道有啥用
13:代理模式:代理类包含被代理类的对象的字段,代理类的构造函数传入被代理对象,在代理类写被代理类的同名方法,在此方法中调用原方法并在外部加以修改,如果要修改原方法内部,使用反射
:用途:和接口相似:接口是方法抽象,代理模式是对象抽象,对象不确定,由别人传入,或者是另一种情况:需要修改一个类的方法
6.9.10.14.15.16没听过


数据库
1.连接池:连接对象的集合,连接资源宝贵需要对连接管理 操作结束需要关闭连接 对象置空
建立一个连接要耗费资源 保持连接要耗费资源 连接池的意义就是对于常用的连接保持开启 ,超出数量的连接才创建和关闭
内置了一个list用于保存连接对象,自制的连接池就算放回了也可以继续使用的
3.只知道group by//分组查询 select * form 表 group by 列名 ,按一个的项分组,比如gender 男的一组女的一组,应该和其他条件比如count一起使用
having就是where,where在使用函数时无法使用换having
4,字符和字符串,char没用过,可能只能单字符吧
5.索引吧,建立索引,主键本身就是一个索引,其他不重复的列也可以作为索引,用索引作为条件查起来快,只知道这个
6.只记得一个索引类型是不重复
789不会


实战:
1.可能是服务器负荷过大,配置一个struts自带的拦截器execAndWite,当用户访问action时时间过长使其跳转到一个页面重复提交请求,可以让action先跳转到别的页面缩小问题的范围,或者先注释掉service的调用,同样是缩小问题范围
4:简单,所以具体代码就不写了,先私有化构造函数,class下声明自己实例的变量,在静态代码块或者直接在class下新建自己实例对象;在写个getInstance获得这个对象,懒汉式的就在方法内创建对象,如果为对象的字段为空就创建,不为空就直接返回这个对象好了
23567都不会,后面前端的东西不会


zookeeper常见面试题
zookeeper是如何保证事务的顺序一致性的
zookeeper采用了递增的事务Id来标识，所有的proposal都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行


zookeeper是如何选取主leader的？
当leader崩溃或者leader失去大多数的follower，这时zk进入恢复模式，


zk中znode类型有四种，持久化目录节点 持久化顺序编号目录节点(有顺序 能够在注册机器等许多场景用到) 临时目录节点 临时顺序编号节点
zk的通知机制
client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。


zk的配置管理
程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用water通知给各个客户端 从而更改配置。
zk的命名服务
命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。


分布式通知和协调
对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点的watcher的所有客户端。
对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。


机器中为什么会有master；
在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行master选举。

redis面试题
https://www.cnblogs.com/jiahaoJAVA/p/6244278.html
https://www.cnblogs.com/Survivalist/p/8119891.html
