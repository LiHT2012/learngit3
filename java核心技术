低  ------------------------------------>  高
byte,short,char—> int —> long—> float —> double
各自的位数，依次：8,16,16,32,64,32,64
所有的包装类（8个）都位于java.lang包下，分别是Byte，Short，Integer，Long，Float，Double，Character，Boolean

在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
4. 转换过程中可能导致溢出或损失精度，例如：
int i =128;
byte b = (byte)i;
因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。

----
this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字
-----

子类中的抽象方法不能与父类的抽象方法同名。
抽象类是必须被继承的才有其意义的，因此，final是不能用来修饰抽象类的。

----
值传递：Java中原始数据类型都是值传递，传递的是值的副本，形参的改变不会影响实际参数的值；

引用传递： 传递的是引用类型数据，包括String,数组，列表，map，类对象等类型，形参与实参指向的是同一内存地址，因此形参改变会影响实参的值。
----

.访问权限的控制，也称为具体实现的隐藏。制定规则（如使用访问权限，设定成员所遵守的界限），是防止客户端程序员对类随心所欲而为。

（3）控制对成员的访问权限的两个原因：
.使用户不要碰触那些不该碰触的部分，对类内部的操作是必要的，不属于客户端程序员所需接口的一部分；
.让类库设计者可以更改类的内部工作方式，而不会对客户端程序员产生重大影响；访问权限控制可以确保不会有任何客户端程序员依赖于类的底层实现的任何部分。

如果向上转型，不能调用那些新的方法（如Animal an = new Cat()，an是不能调用Cat中有的而Animal中没有的方法，会返回一条编译时出错消息），所以向上转型会丢失具体的类型信息；

构造方法不能被继承；方法和属性可以被继承；

final参数：final修饰参数后，在方法体中不允许对参数进行更改，只可以读final参数。主要用于向匿名类传递数据。

.类中所有的private方法都隐式地指定为final的。

加载的含义：通常，加载发生在创建类的第一个对象时，但访问static域或static方法时，也会发生加载。static的东西只会初始化一次。
加载顺序：父类静态域——父类静态块——子类静态域——子类静态块——父类成员变量及代码块——父类构造器——子类成员变量及代码块——子类构造器。

加载的动作只会加载一次，该类的静态域或第一个实体的创建都会引起加载。

变量的初始化：变量的初始化总是在当前类构造器主体执行之前进行的，且static的成员比普通的成员变量先初始化。

@PostConstruct注释的方法，会在构造方法之后，init方法之前进行调用。

注解会多多少少地影响到服务器的启动速度。服务器在启动时候会遍历Web 应用的WEB-INF/classes下的所有class文件与WEB-INF/lib下的所有jar文件,以检查哪些类使用了注解。

有一种情况，在我的servlet初始化加载之前我想处理一些东西，像加载缓存等等。
怎么做。@PostConstruct就派上用场了。那为什么这玩意用的不多呢，这是因为如果初始化之前我们要加载或处理某些玩意完全可以在构造器初始化时就处理了，但这种方法需要自己重写构造器

×××××多态
1.多态只发生在普通方法中，对于域和static方法，不发生多态。子类对象转化为父类型引用时，对于任何域的访问都是由编译器解析。静态方法是与类相关联，而不与单个对象相关联；

2.在继承时，若被覆写的方法不是private，则父类调用方法时，会调用子类的方法，常用的多态性就是当父类引用指向子类对象时。

3.多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

4.多态是同一个行为具有多个不同表现形式或形态的能力。

5.多态就是同一个接口，使用不同的实例而执行不同操作，多态性是对象多种表现形式的体现
=========
多态

允许父类型的引用指向子类型的对象。

实现方式：方法重载（编译器绑定，前绑定）和方法重写（运行期绑定，后绑定）
==========
1.为什么强制每个导出类部分都必须调用构造器的原因？（基类的构造器总是在导出类的构造过程中被调用）

只有基类的构造器才具有恰当的知识和权限对自己的元素进行初始化，因此必须令所有的构造器都得到调用。导出类只能访问自己的成员，不能访问基类中的成员（通常是private类型）。

----
14、==与equals方法的区别：

（1）基本数据类型与引用数据类型

1.基本数据类型的比较：只能用==；

2.引用数据类型的比较：==是比较栈内存中存放的对象在堆内存地址，equals是比较对象的内容是否相同；

（2）特殊：String作为一个对象

例子一：通过构造函数创建对象时。对象不同，内容相同，"=="返回false，equals返回true

String s1 = newString("java");
String s2 = new String("java");

System.out.println(s1==s2);            //false
System.out.println(s1.equals(s2));   //true

例子二：同一对象，"=="和equals结果相同

String s1 = newString("java");
String s2 = s1;  //两个不同的引用变量指向同一个对象

System.out.println(s1==s2);            //true
System.out.println(s1.equals(s2));   //true

如果值不相同，对象就不相同，所以"=="和equals结果一样

String s1 = "java";
String s2 = "java";   //此时String常量池中有java对象，直接返回引用给s2；

System.out.println(s1==s2);            //true

System.out.println(s1.equals(s2));    //true

字面量形式创建对象时：

如果String缓冲池内不存在与其指定值相同的String对象，那么此时虚拟机将为此创建新的String对象，并存放在String缓冲池内。

如果String缓冲池内存在与其指定值相同的String对象，那么此时虚拟机将不为此创建新的String对象，而直接返回已存在的String对象的引用。

（3）String的字面量形式和构造函数创建对象

1）String s = "aaa";采用字面值方式赋值

1.查找StringPool中是否存再“aaa”这个对象，如果不存在，则在StringPool中创建一个“aaa”对象，然后将String Pool中的这个“aaa”对象的地址返回来，赋给引用变量s，这样s会指向String Pool中的这个“aaa”字符串对象；

2.如果存在，则不创建任何对象，直接将String Pool中的这个“aaa”对象地址返回来，赋给s引用。

2）String s = new String("aaa");

1.首先在StringPool中查找有没有"aaa"这个字符串对象，如果有，则不在String Pool中再去创建"aaa"这个对象，直接在堆中创建一个"aaa"字符串对象，然后将堆中的这个"aaa"对象的地址返回来，赋给s引用，导致s指向了堆中创建的这个"aaa"字符串对象；

2.如果没有，则首先在String Pool中创建一个"aaa"对象，然后再去堆中创建一个"aaa"对象，然后将堆中的这个"aaa"对象的地址返回来，赋给s引用，导致s指向了堆中所创建的这个"aaa"对象。
----
try catchfinally

1.finally里面的代码一定会执行的；

2.当try和catch中有return时，先执行return中的运算结果但是先不返回，然后保存下来计算结果，接着执行finally，最后再返回return的值。

3.finally中最好不要有return，否则，直接返回，而先前的return中计算后保存的值得不到返回

JNI java native interface

设计作用：主要实现和其他语言的通信，c和c++。标准的Java类库中可能不支持程序所需的特性，或已经有了一个用其他语言编写的库或程序，但是现在希望用到Java程序中，则需要使用JNI。

使用场景：JDBC实现连接数据库，Thread.sleep()方法。

path是windows的环境属性，用于指定可执行命令的路径；classpath是指在Java程序执行的时候，用于指定类的加载路径。
-----
final是Java的一个关键字，用于定义不能被继承的类，不能被覆写的方法，不能修改的常量。

finally是Java的一个关键字，是异常处理操作的统一出口。

finalize是Object类中所提供的一个方法，用于在对象回收之前进行收尾操作。

被声明为final的方法不可以重写（父子类继承关系），但是可以重载（同一个类中）。
如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。

finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，
所以一般情况下内存问题不用程序员操心。但有一种JNI(JavaNative Interface)调用non-Java程序（C或C++），
finalize()的工作就是回收这部分的内存。

Java实现可移植性的原理

Java程序最终通过字节码文件运行，运行的时候字节码需要JVM支持，但是在不同的操作系统中有不同的JVM，程序不用关心操作系统，只关心JVM，只要JVM不改变，程序可以在操作系统间任意移植。
======
&（普通与）和|（普通或）是指所有条件都需要判断；

&&称为逻辑与（短路与）是如果前面的条件不满足false，则后面的不再进行判断；||称为逻辑或（短路或）如果前面的条件满足true则后面的不再判断；

在开发之中为了性能的提高，不需要所有条件进行判断，所以使用短路与和短路或操作；

&和|除了用于逻辑运算以外，还进行位运算的操作。
======

String对象的两种实例化方式的区别

1.首先String对象的实例化有两种：直接赋值和构造方法完成。

2.直接赋值：在常量池中创建该字符串；

3.构造方法：先判断在字符串常量池中是否包含该字符串，若包含该字符串，则在堆中直接创建这个字符串对象并返回该对象引用；
若不包含，则先在堆上创建，然后在字符串常量池中也创建，最后把返回堆上对象引用。

枚举
1.当使用“enum”定义枚举类型时，实质上是继承java.lang.Enum类型；

2.每个枚举的成员其实就是定义的枚举类型的一个实例，他们都被预设为final，所以无法改变他们，也是static成员，所以可以通过类型名称直接使用它们，且他们是公开的public的。

3.特性：final static public的。

4.在编译时期就确定该枚举类型具有几个实例，分别是什么。在运行期间我们无法再使用该枚举类型创建新的实例，这些实例在编译期间就已经完全确定下来。

可变参数必须要作为方法参数的最后一个参数，即一个方法不可能具有两个或以上的可变参数。

如果一个对象被多个引用所指向，那么无论哪个引用对对象的属性进行修改，都会反映到其他的引用中去。

1）关于int b = a++，作用：先将a赋给b，然后再让a自增1。

2）关于int b = ++a，作用：先将a的值自增1，然后再将自增后的a赋给b。

=====
JRE与JDK

1）JRE：Java Runtime Environment，Java运行环境，包括JVM和Java程序所需的核心类库等。

2）JDK：Java Development Kit，Java开发工具包，JDK是提供给Java开发人员使用的，其中包含了Java的开发工具（编译工具javac.exe和打包工具jar.exe等），也包括了JRE。所以安装JDK，就不用单独安装JRE。

3）如果是命令行模式：编译器javac进行编译：javac 源文件名.java——编译通过后，对class字节码文件运行：java 类名

4）运行与工作原理

5）path环境变量配置的作用：程序开发过程中，不能将源代码写入JDK的安装目录，因此需要将源程序保存到任意位置的指定目录（英文目录），所以需要使javac指令在任意目录下可以运行。通过配置path环境变量，将javac指令所在目录及JDK安装目录下的bin目录配置到path变量下，即可使javac指令在任意目录下运行。

6）使classpath目录中的.class文件可以在任意目录运行。

7）path和classpath的区别：path环境变量里面记录的是可执行性文件，如.exe文件，对可执行文件先在当前路径去找，如果没找到就去path环境变量中配置的路径去找。而classpath环境变量里记录的是java类的运行文件所在的目录。
====
反射

（1）反射机制

1）定义：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.

2）获取Class对象的三种方式

第一种方式：

Person p = new Person();

Class c = p.getClass();

第二种方式：任意类都具备一个class静态属性

Class c2 = Person.class;

第三种方式：将类名作为字符串传递给Class类的静态方法forName

Class c3 =Class.forName("Person");

（2）动态代理

1）在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib

2）Proxy类中的方法创建动态代理类对象

public static Object newProxyInstance(ClassLoaderloader,Class<?>[] interfaces,InvocationHandler h)

最终会调用InvocationHandler的方法

Proxy类中创建动态代理对象的方法的三个参数；

ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载；

Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了；

InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上。

3）InvocationHandler

Object invoke(Object proxy,Method method,Object[] args)

每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke 方法来进行调用。

InvocationHandler接口中invoke方法的三个参数：

proxy:代表动态代理对象

method:代表正在执行的方法

args:代表调用目标方法时传入的实参

4）Proxy.newProxyInstance

创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，
而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。
System.out.println(u.getClass().getName());

快速报错机制
1）出现原因：在迭代遍历某个容器的过程中，另一个进程介入其中，并且插入、删除或修改此容器内的某个对象，则会出现问题：也许迭代过程已经处理过容器中得到该元素了，也许还没处理，也许在调用size()之后容器的尺寸收缩了。

2）快速报错（fail-fast）机制：探查容器上除了你的进程所进行的操作以外的所有变化，一旦发现其他进程修改容器，立即抛出ConcurrentModificationException异常，即不是使用复杂的算法在事后来检查问题。
===========
public staticvoid main(String[] args)方法的必要性

1）是Java程序的入口方法，JVM在运行程序时，会首先查找main()方法；

2）public是权限修饰符，表明任何类或对象都可以访问这个方法；

3）static表明main()方法是一个静态方法，即方法中的代码是存储在静态存储区的，只要类加载后，就可以使用该方法而不需要通过实例化对象来访问，可以直接通过类名。

4）main()不能用abstract修饰，但可以用final和synchronized修饰，且public与static的顺序可以颠倒。

默认的Object.equals()只是比较对象的地址
=====
Arrays的方法

java.util类库中的Arrays类，有一套用于数组的static实用方法。有6个基本方法+1个asList()方法。

1）Arrays.asList()：接收任意的序列或数组作为其参数，并将其转变为List容器；

2）equals()：用于比较两个数组是否相等（deepEquals()用于多维数组）；

3）fill()：是用同一个数值进行填充数组的各个位置，针对对象而言，就是复制同一个引用进行填充；

4）sort()：用于对数组排序；（对于数值排序，小于8的使用插入排序，大于等于8个元素使用快速排序；对于对象排序，使用合并排序）；

5）binarySearch()：用于在已经排序的数组中查找元素；

6）toString()：差生数组的String表示；

7）hashCode()：产生数组的散列码；
=====
面向对象：

1）思想：是站在现实世界的角度去抽象和解决问题，把数据和行为都看作是对象的一部分，可以让程序员以符合现实世界的思维方式来编写和组织程序。

2）原则：

单一职责：一个类只做它该做的事（高内聚）；

开放封闭：对扩展开放，对修改关闭；

里氏替换：任何时候都可用子类型替换父类型；

依赖倒置：面向接口编程（抽象类型可被任何一个子类所替代）；

合成聚和复用：优先使用聚合或合成关系复用代码；

接口隔离：一个接口只应描述一种能力，接口应该是高内聚的（小而专一）；

迪米特法则：最少知识原则，一个对象应对其他对象尽可能少的了解。
=======
1）异常介绍

1）编译时异常

除了RuntimeException及其子类,Exception中所有的子类都是,这种异常必须要处理,要不编译通不过

2）运行时异常

RuntimeException及其子类都是,这种异常不用处理,编译会通过,不过这样的程序会有安全隐患,遇到这种异常是需要改代码的

3）严重错误问题

用Error进行描述,这个问题发生后,一般不编写针对代码进行处理,而是要对程序进行修正.通常都是由虚拟机抛出的问题

（2）Throwable中方法

getMessage()

获取异常信息，返回字符串。

toString()

获取异常类名和异常信息，返回字符串。

printStackTrace()

获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。

printStackTrace(PrintStream s)

通常用该方法将异常内容保存在日志文件中，以便查阅。

（3）throws和throw的区别

1）throws

·       用在方法声明后面，跟的是异常类名；

·       可以跟多个异常类名，用逗号隔开；

·       表示抛出异常，由该方法的调用者来处理；

·       throws表示出现异常的一种可能性，并不一定会发生这些异常。

2）throw

·       用在方法体内，跟的是异常对象名；

·       只能抛出一个异常对象名；

·       表示抛出异常，由方法体内的语句处理；

·       throw则是抛出了异常，执行throw则一定抛出了某种异常 。

（4）try和throws区别

如果该功能内部可以将问题处理，用try，如果处理不了，则交由调用者处理，用throws进行抛出异常。

区别：后序程序需要运行，则用try；后序程序不需要继续运行，则用throws；

java的开发模式：
MVC是一个很常用的程序开发设计模式，M-Model（模型）：封装应用程序的状态；V-View（视图）：表示用户界面；C-Controller（控制器）：对用户的输入作出反应，创建并设置模型。
